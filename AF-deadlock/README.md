<div class="no-overflow" id="yui_3_17_2_1_1683740574395_100"><h3>Exercício 1</h3>
<p id="yui_3_17_2_1_1683740574395_103">O programa dado cria duas threads <strong>worker1</strong> e <strong>worker2</strong> que fazem uma operação misteriosa <strong>20</strong> vezes. Cada uma dessas threads soma o resultado em uma variável global e coloca um valor em uma lista, também global. Além da atualização dessas variáveis globais, as próprias operações misteriosas das threads não podem ser executadas concorrentemente. Ou seja, se <strong>worker1</strong> está realizando sua operação (<strong>operacao_worker1()</strong>), a thread <strong>worker2</strong> não pode executar <strong>operacao_worker2()</strong>.</p>
<p id="yui_3_17_2_1_1683740574395_109">Ninguém sabe o que o programa faz, pois quando é executado, ele quase sempre trava. Verifique se está ocorrendo um impasse (<em>deadlock</em>) e, se for o caso, realize as alterações necessárias para que os impasses não ocorram.</p>
<ul>
<li><span style="color: #ff0000;">O arquivo <strong>helper.c</strong> não deve ser alterado!</span></li>
<li>Não remova nem renomeie o mutex ou semáforo.<span style="color: #ff0000;"></span></li>
</ul>
<h3>Exercício 2</h3>
<p id="yui_3_17_2_1_1683740574395_110">O programa dado simula uma agência bancária. As contas são armazenadas em um array (veja <strong>banco.h</strong>) e contêm um identificador, um saldo e um mutex. O programa cria <span style="font-family: courier new, courier, monospace;"><strong>NUM_CAIXAS</strong></span> threads que executam <span style="font-family: courier new, courier, monospace;"><strong>TOTAL_TRANSFERENCIAS</strong></span> transferências entre as <span style="font-family: courier new, courier, monospace;"><strong>NUM_CONTAS</strong></span> contas existentes no banco. As transferências são geradas aleatoriamente. O caixa escolhe uma conta de origem, uma conta de destino, um valor e realiza a transferência chamando a função <span style="font-family: courier new, courier, monospace;"><strong>transferir(conta_t* origem, conta_t* destino, double valor)</strong></span>. Qualquer transferência é permitida; se a conta de origem tiver saldo insuficiente, o cheque especial será utilizado e o saldo ficará negativo.</p>
<p id="yui_3_17_2_1_1683740574395_108">Para manter os saldos íntegros, a função <span style="font-family: courier new, courier, monospace;"><strong>transferir()</strong></span> utiliza o <strong>mutex</strong> particular de cada <span style="font-family: courier new, courier, monospace;"><strong>conta_t </strong></span>envolvida na transação. Afinal, se a mesma conta participar de duas transferências paralelamente, o saldo pode ser corrompido, causando o desaparecimento ou surgimento de dinheiro. Por isso, uma das transferências precisa aguardar que a outra termine antes de iniciar (ex.: se caixa 1 está transferindo valores da conta 2 para a 3, caixa 2 precisa esperar para poder transferir da conta 4 para a 3). No entanto, algo não está certo nessa função, já que o programa simulador costuma travar após poucas transferências. Você deve modificar <strong>apenas a função transferir() </strong>de modo a&nbsp;resolver esse problema.</p>
<ul>
<li><span style="color: #ff0000;">Não altere os arquivos <strong>helper.c</strong> e <strong>banco.h</strong> </span>como parte da solução. Durante a correção, esses arquivos serão trocados pelas versões originais.&nbsp;</li>
</ul>
<h3>Dicas</h3>
<p id="yui_3_17_2_1_1683740574395_99">Use o GDB, como explicado <a href="https://moodle.ufsc.br/mod/page/view.php?id=4514034" id="yui_3_17_2_1_1683740574395_98">aqui</a>, para identificar onde estão ocorrendo os deadlocks.</p></div>